Components System Design
1. Editor 与代码的交互
a. Editor完全被代码所创建，代码运行时保存当前组件UI创建所需要的所有信息，主要是属性类型，因为这个直接决定了用哪个UI组件来表达该属性，其次是一些与显示相关的属性，比如显示名，tip，最后是一些限制条件，比如属性的最大最小值之类。
b. 代码数据完全由Editor产生的数据所填充，这个是一个自动反序列化的过程，这个过程必须考虑，数据和代码结构不一致的问题，必须设计一套策略可以正确的适应这种情况。
c. 必须开放属性类型种类以及对该种类如何进行UI组织的接口，只有这样才可以使该系统通用到所有的UI库上。
流程：
a. 第一步是代码产生UI所必须的数据，这里必须考虑到暴露接口和属性给使用者。包括注册新的属性以及重写已有的属性处理方法。
b. 暴露这些流程意味着以下几点：
a) 代码只能提供枚举信息代替类型信息，所以这里有个类型与枚举对应的映射。
b) 几个类型可能会有同样的处理方法，比如float和double可能会被同一种枚举信息所代表，所以这里的枚举可能会对应多个类型。
c) 所以类型枚举对于代码来说，是对应类型的，对于editor来说是对应方法的。如果是对应方法，肯定是手动的（因为这里需要灵活）。如果是对应类型，这里存在一部分的灵活性，比如自定义类型，也有不灵活的地方，比如内置默认类型，bool值肯定要对应bool的枚举类型，如果这里完全由人工确认，则显得不智能，没有类型检查；如果交给代码编译来做，则每增加对一个新类型的支持都需要一次静态注册，显得比较冗余。
d) 先考虑代码这边的枚举对应多个类型，如何暴露给使用者动态的操作？无非是提供一个接口让玩家去动态的注册他们的对应关系，如何做到？设想现在有两种用户，一种是wxwidgets用户一种是MFC用户，他们如何才能通用这个系统？枚举对应多个类型，其实是一种从类型到枚举的转换过程（因为从枚举转换到类型是没有意义的，结果不会有确定性）。对类型的查询只有用模板才可以做到，现在问题就是如何把模板的实现暴露给使用者。让使用者在任意地点都可以查询到这个信息。这个注册还是放到一个公用头文件中比较好，并且应该由第三方库管理起来。通过在库的头文件增加一个专门用于区分的模板类，解决了该问题。
e) 以上一点剩余的问题是，如何识别模板类型。譬如vector和map。因为无法对模板类进行准确定义。目前是为带模板参数的类专门写了一个宏应对，未来应该有办法让他们共用一个宏。
f) ==========以上解决了静态映射的问题=========
g) 现在考虑枚举对应单个处理方法。这毫无疑问是一个一一映射的过程，所以果断选用map注册，但是问题在于处理接口用什么方式暴露给用户。有三个选择，1全局函数 2重写对象虚方法 3对象。
h) 全局函数不符合C++的OO思想，并且难于管理，排除；虚方法只能处理行为多态，不能动态增加行为，排除；所以决定最后由库提供基类，用户必须一一实现该基类的子类以达到行为和数量都动态的目的。
i) 提供了PropertyDescription基类，并把UIHandler作为一个纯虚接口实现，在基类构造时会自动去注册。用户必须实现自己的所有子类，才能响应UI需求。
j) ============以上解决动态映射的问题==============
c. 现在开始定义用户接口	
a) 库提供函数接口或者宏，让用户输入一切UI所需要的信息。这些信息包括：
1. 基本信息：1.类型 2. 显示名 3.所属分类 4.是否可以由UI修改 5.属性tip 6.颜色
2. 扩展信息：1.取值范围 2.字符串长度 3.spin组件支持 4.最大元素数量 5.允许动态添加/删除
b) 以上信息可以直接保存在对应的PropertyDescription里面，正好合适。
c) 提供自定义信息结构。由指针来处理这种情况。如果发现用户指定的属性是一个指针，则将该指针指向的类型的所有property取过来。
d) 现在的问题是，这个指针属性，必须也要有propterylist，所以这里必须要有一个抽象“可以拥有propertylist的对象”，然后让组件或数据结构都继承自它，之前疏忽了这里，因为数据结构也可以由映射关系，它并不一定是组件。这里又会导致，以后如果要写反射数据结构，那么它必须要我们手动写一个构造函数告知它的property情况，这里很不爽，但是也没有办法。因为我们与editor的属性信息是通过动态来保证的，必须要有函数去做这件事情，所以这个任务就交给了构造函数。
e) 现在就是定义调用接口，和定义序列化数据结构的时候。
对于接口来说，它需要自动的解析变量，传入参数，以构建一个properDescription。现在比较困难的问题是，如何定义友好的借口以方便不同的UI库共享components。
f) 如何处理数据结构以最优雅的满足UI的识别。首先我们需要关心的东西是哪些信息是必须的。1.属性类型。 2.属性数据。 3.属性数据的长度（以方便二进制读取）。至于对这些数据如何解析，可以交给子类的虚函数去处理。另外就是，谁来负责导出数据的工作，以及如何组织这个数据的导出工作。这里最好有一个管理者来统一这件事情，如果没有的话，很难处理相同类型重复数据输出的问题，所以我觉得这个地方 由mananger来负责比较好，优点是，统一了调用接口，并且manager很清楚当前有多少种不同类型的property。
g) 设计语法接口，让程序解析一些特例化的属性。现在的做法是直接写格式化字符串，然后提供语法解析器。比较复杂点的是如何处理list类型的变量，如果要考虑在默认值中进行初始化的话，则比较困难。所以这里暂时不考虑。
h) 对于映射指针的规则，指针必须指向reflectbase的子类，因为我们对属性的映射是通过将成员变量包装成property去注册的方式来实现的，所以可以映射的属性类型必须是我们支持的基类类型或者已经持有property的对象（即reflectbase），对于这种情况下的处理，放在了AddProperty接口进行处理。

3.存储Property数据格式给UI。
a.存储是以组件为单位进行的，所以必须为每个组建设置一个唯一的ID用于标示。不用枚举的原因在于，枚举具体值会被上下文所影响，所以这个地方我们使用GUID.
b.组件包含两种ID,一种是GUID，标示其类型，一种是普通ID，标示其实例。后者必须要考虑到以后共同开发作业时，ID分配的冲突，目前有一个办法就是写一个keyserver，但是可以考虑下有没有更好的实现方法。
c.格式：
GUID（32bit）
PropertyCount（32bit）
Property1 size（32bit）
Protery type(16bit)
…details for property1
d.为了让UI能显示所有组件，需要有一个组件注册机制。这样才能导出所有组件信息。于是写了ComponentManager用于注册和统一操作（譬如导出）
=============================以上完成了数据从代码到editor的导出==============
