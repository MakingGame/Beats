2. -整理CWMIDetector::GetItemInfo,返回值应该用serializer来做。并且每次调用应该指定server的name，可以用一个成员变量进行缓存
    当新的查询与原来不一致时再重新connect
3. -获取CPU信息的时候尝试用smbios的firmwaretable，避免读注册表，一个是安全稳定，二个是可以和memroy共用一种方式
4. -尝试将debugtool中硬件检测的部分独立为第三方库，并将功能做得更加强大。
0. -加速继承网络模块。
0. -建立spy工程。
0. -增加MD5模块
8. -为memory detector添加支持动态load的dll，方法是事先给一个框填写dll的名字。
9. -增加A星
10.-增强硬件检测功能，包括温度刷新之类，尽量朝专业软件靠近。
11.-解决在windows7下面，读取EDID和harddisk失败的bug。
0.-内存检测必须重载new new[] delete delete[] DEBUG_NEW以防止他人重载，还有alloc和free以及所有相关的函数。
0.-为内存堆栈加一个参数，这样可以过滤堆栈的深度。
14.-memory不能hook一个叫msvcp80d.dll的dll，尝试找出为何会链接这个dll以及如何将其在名单中过滤。
0.-继续增强过滤刷新memory grid的功能，因为现在支持了time，所以很容易知道一个数据是否需要刷新。
0.-据推想大概会这样的bug：目前内存分配稳定，突然有一个操作会删除第一个记录，这时候UI不会刷新。这个需要验证。
0.-在debugtool的memory数据过大，反应过慢的情况下，关闭游戏会导致crash。譬如hook一个ceguibase.dll.
0.-完成对memory hook的重构，必须用最大覆盖面去hook 导入表，见第12条。
0.-需要动态控制堆栈的打印层次和显示地址的打印层次，比如如果工程使用了DEBUG_NEW这样的宏，那在打印地址的时候就要多去掉一层嵌套。
0.-为hook memory的几个函数加上critical section，如同new本身所做的一样，否则会出问题。
21.-提供取消堆栈的功能。
0.-查看内存的那个grid可以想办法缓冲，比如当前屏幕正中央是第100条，那我只把90条到110条刷新到UI上，如果用户拉滚动条，则再重新加载，有点类似无缝场景。
23.-搞个内存示意图，时间曲线也好，范围分布的圆形也不错，总之提供一点直观的图形。
0.-内存条目数量过大的情况下，做一个提示框。提示数量很大，如果默认开始就是自动刷新会导致很卡。
0.-updatememorydata函数中不应该去取实际的memorydetector数据（总共申请内存，总共内存块，最大内存块），应该直接用缓存中的，否则结果会不一致。
0.-针对以上一条，可以把所有缓存数据组织成一个snapshot的数据结构，同步一次得到所有缓存数据。以后的存取都不用再同步。
0.-让BEATS_ASSERT支持无参。
0.-内存检测自动更新关闭，切换查看方式就没有更新了，单击空白处崩溃。
29.-让memory的信息可以按照模块来划分，比如我hook了a.dll b.dll c.exe，我可以通过按模块查看来获取一个模块的内存情况
0.-双击栈信息可以自动跳到那个文件。
31.-提供自动刷新的频率。
32.-选中内存条目，需要打印该条目的堆栈时，应该将堆栈缓存下来，而不是去取当前数据的堆栈信息，如果那个条目在当前时刻不存在，则会崩溃。
0.-仔细想一下刷新的意义何在，每次获取memory record snapshot是只要当前浏览类型的那张表数据就够了（这样每次缓存传输的数据量会最小），
    还是所有类型的表都传过来（比如按地址，按时间，按位置等）这样可以在不更新的时候迅速的切换浏览类型看缓存文件而不用更新，但是代价就是
    每次更新都会多几倍数据。特别是在条目达到10万级的时候，会很恐怖。(已经解决，我会只传送固定数量的条目)
0.-做数据加密，比如文件内容倒置之类的。
35.-增加数据加密的种类（不知道是否有意义，可能为以后打包资源有一定的帮助），可以想到的有，内存数据字典替换等。
36.-增加可视化的组件脚本系统。
37.-把功能全部剥离成dll吧。
38.-组件系统中，如果是新建工程，新建文件，新建组件时，无法用搜索组件的功能。